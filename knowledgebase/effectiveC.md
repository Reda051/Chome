2024/11/22
C语言中的所有类型，要么是函数类型，要么是对象类型。
Object是可以在其中表示值的一块存储区域。
变量有一个声明的类型，该类型可以告诉你该变量的值所代表的对象种类。
函数并非对象，但同样有种类。函数类型是由其返回值类型以及参数的数量和类型共同决定的。
指针——可视为地址——对象或函数在内存中的存储位置。
指针的类型派生自函数或对象的类型，后者称为引用类型。
在声明多个变量的过程中，注意：
如果变量是指针或数组，或者是不同的类型，那么这种做法就会造成混乱。——请注意，混乱但可以正常声明。
对象的存储期决定了对象的生命期。局部变量具有自动存储期，当所在的语句块结束执行时，这类变量就会被销毁了。
C语言区分形式参数parameter，和实际参数argument。
形参是在函数声明中声明的对象，需要在执行该函数时赋值。
实参是在函数调用表达式中出现的若干表达式，彼此之间用逗号分隔。

C 是一种按值调用[call-by-value,也称按值传递(pass-by-value)]的语言，这意味着提供函数参数时，参数值会被复制到其他变量，以此在函数内使用。
将作为实参的对象的值赋给对应的形参。如果形参有变化，调用方（caller）的值不会受到影响。
所以如果想要定义swap函数交换两个变量的值的时候，需要用到间接运算符（*）声明指针和解引用指针。
Example:void swap(int *pa ,int *pb){
int t=*pa;
*pa = *pb;
*pb = t;
return ;}
如果出现在函数声明或定义中，则*会被作为指针声明器(pointer declarator)的一部分，表明参数是指向特定类型的对象或函数的指针。
在函数内，当在表达式中使用单目运算符*时，该运算符会将指针解引用为对象。

Q:What the fuck is 解引用。
A:解引用（Dereferencing）是编程中的一个重要概念，特别是在处理指针时。以下是解引用的简要解释：
**解引用（Dereferencing）**：
- **指针的概念**：在C语言等支持指针的编程语言中，指针是一个变量，它存储了另一个变量的内存地址（也就是指针“指向”了另一个变量）。
- **解引用的定义**：解引用就是通过指针获取其指向的实际数据值的操作。换句话说，解引用是将指针转换为它所指向的变量的值。
- **语法**：在C语言中，解引用使用星号 `*` 操作符。例如，如果你有一个指向整数的指针 `int *ptr;`，你可以通过 `*ptr` 来访问 `ptr` 所指向的整数值。
- **示例**：
  ```c
  int value = 10;
  int *ptr = &value;  // ptr 现在指向 value
  int dereferenced_value = *ptr;  // dereferenced_value 现在是 10
  ```
- **目的**：解引用的主要目的是允许程序员通过指针间接访问和修改内存中的数据。这在动态内存分配、数组处理、函数参数传递等场景中非常有用。
- **注意事项**：
    - 解引用一个未初始化的指针或一个指向无效内存的指针会导致未定义行为，可能会导致程序崩溃或其他错误。
    - 解引用一个空指针（NULL）在运行时会导致程序崩溃。
- **用途**：
    - 访问数组元素：`*(arr + i)` 等价于 `arr[i]`。
    - 修改指针指向的值：`*ptr = 20;` 会将 `ptr` 指向的变量值改为 20。
    - 函数返回值：通过返回指针，可以让函数返回多个值或复杂的数据结构。
解引用是指针操作的基础，是理解和使用指针的关键。

&是取址运算符(address-of operator),会产生指向该操作数的指针。swap(&a,&b);才可以正常的实现swap的功能。
Scope作用域，C提供了4种作用域：文件、块、函数原型和函数。
对象或函数标识符的作用域是由其声明位置决定的。如果声明位于所有语句块或参数列表之外，那么该标识符就具有文件作用域，这意味着作用域是其所在的整个文件以及声明位置之后的所有包含文件。
函数作用域是位于函数定义的左右花括号内。标签(label)是唯一一种具有函数作用域的标识符。
内部作用域必须完全被包含在外围作用域种。
如果内外声明相同的标识符，则外标识符会被内标识符所遮蔽。优先使用内部标识符。
作用域应用于标识符，生命期应用于对象。
在文件作用域种声明的对象具有静态存储期，这类对象的生命期是程序的整个执行期间，对象种保存的值在程序启动前初始化。

可以在块作用域中是哦那个存储类说明符static声明具有静态存储期的对象，当函数存在后，这类对象依然存在。
尽可能的限制对象的作用域是一种良好的软件工程实践。
静态对象必须使用常量值而不能用变量初始化。
常量值指的是字面常量，比如1、'a'、0xFF、enum成员以及alignof或sizeof等运算符的结果，不能是const限定对象。
对齐方式（alignment)描述了为给定对象分配的连续地址之间的字节数。CPU在访问对齐数据（example:数据地址 是数据所占空间大小的整数倍）和未对齐数据时可能会表现出不同的行为。
字是一种天然的、具有固定长度的数据单位。
通过malloc动态分配的内存需要充分对齐包括数组和结构在内的所有标准类型。
C11中引入了机制来指定对齐方式。对齐方式被表示为size_t类型的值。
对齐方式按照由弱到强进行选择。
(Q:这个对齐方式没明白什么意思呢)
A:在C语言中，对齐（Alignment）是指在内存中数据存储的方式，它涉及到数据在内存中的位置和字节边界。C语言中的对齐主要有以下几个方面：
数据对齐：
在内存中，数据（如变量、结构体成员等）通常会被存储在特定的边界上，以提高内存访问的效率。不同的数据类型可能有不同的对齐要求。例如，int类型可能需要4字节对齐，double类型可能需要8字节对齐。
对齐规则：
编译器通常会根据数据类型的大小来决定其对齐方式：
- 基本数据类型（如char、short、int、float、double等）通常会按照其自身大小的倍数对齐。
- 结构体（struct）中的成员会按照成员自身类型的大小对齐。
- 结构体的整体大小也会被对齐到其最大的成员对齐要求的倍数。
对齐的好处：
- 提高访问效率：在某些体系结构上，对齐的内存访问可以减少内存访问的次数，因为对齐的数据可以一次性加载到寄存器中。
- 避免性能损失：在某些情况下，非对齐的内存访问可能会导致性能损失，甚至可能引发硬件异常。
对齐的问题：
- 内存浪费：为了满足对齐要求，可能会在数据之间填充一些空字节，导致内存使用效率降低。
- 兼容性问题：不同编译器或平台上的对齐要求可能不同，这可能导致结构体在不同平台上的大小不一致。
控制对齐：
可以使用#pragma pack指令或__attribute__((__packed__))属性来控制结构体的对齐方式，强制编译器忽略默认的对齐规则。
举个例子：
```c
struct Example {
    char c;    // 1字节
    int i;     // 4字节
};
```
在这个结构体中，char类型只需要1字节对齐，但int需要4字节对齐。因此，编译器可能会在char和int之间填充3个字节，以使int对齐到4字节的边界。结构体的总大小将是8字节，而不是预期的5字节。

2024/11/23
对象类型：布尔类型、字符类型和数值类型。
_Bool的对象只能存储0、1，布尔类型是在C99中引入的，类型名的下划线是为了在已自行声明了bool或者boolean标识符中的程序做出区分。
#include <stdbool.h>
_Bool可以读取，但是最好还是写成bool,这是c语言长期的发展方向。

字符类型：char、signed char和unsigned char。
char类型的对象必须能够表示执行环境所要求的最小字符集（称为基本执行字符集），其中包括大小写字母、10个十进制数字(0~9)、空格以及标点符号和控制字符。
char类型不适用于整数数据，更安全的做法是分别使用signed char和unsigned char表示比较小的有符号整数值和无符号整数值。
全新的宽类型，能容纳更大的字符集wchar_t，可以将大字符集中的字符表示为宽字符，这种字符要比基本字符占用更多的存储空间。
实现通常选择16位或32位来表示一个宽字符。

数值类型：
有符号整数类型可以用于表示负数、正数和0。signed char、short int、int、long int、long long int
int可以在其他有符号整数类型的声明中忽略，long long=long long int.
Q：long int和int 有什么区别？这几个大小上的能力是如何表现的？

A:

无符号整数类型，显然就是unsigned char\unsigned short int\unsigned int\unsigned long int\unsigned long long int只能表示正数与0

uintmax_t和intmax_t是可用的最宽整数类型的类型定义，来自于<stdint.h>或者<inttypes.h>\\这里扩展写一下：

枚举enumeration,enum,如果没有使用=运算符为第一个枚举器指定值，则其枚举常量值为0，之后每个+1；
枚举常量的实际值必须能以int类型表示，但具体类型是由实现定义的。

浮点类型：float、double、long double。
浮点算术类类似于实数算术。

void类型：void本身表示不含有任何值，void*表示指针可以引用任意对象???(?)

函数类型：函数类型属于派生类型，是由返回值类型以及参数的数量和类型派生而来的。
*函数的返回类型不能是数组类型。
在声明函数的过程中，不建议省略标识符(int,int)这种的，虽然可以但是不建议！！！
在没有参数的情况下(void)即可。
int max(int a,int b){return a>b?a:b}
~~~带有参数类型列表的函数类型称为函数原型function prototype.
编译器使用这些信息核实函数定义以及调用中的参数数量和类型是否正确。
~~~
派生类型由其他类型构造而来，包括指针、数组、类型定义、结构和联合。
指针类型派生自其所指向的函数或对象类型，后者称为引用类型。
指针与取址运算符可以相互抵消。
多维数组(矩阵).

类型定义:
可以使用typedef生成现有类型的别名。但要注意，typedef并不会创造新类型。
结构类型(struct)包含顺序分配的成员对象。每个对象都有自己的名称，类型可能并不一致。
**C语言中的结构体（struct）**是用来创建自定义数据类型的。它允许你将不同类型的数据组合在一起，形成一个单一的复合数据类型。以下是关于结构体的一些基本用法：
### 1. 定义结构体
你可以使用`struct`关键字来定义一个结构体：
```c
struct Person {
    char name[50];
    int age;
    float height;
};
```
这定义了一个名为`Person`的结构体，它包含了名字（字符串）、年龄（整数）和身高（浮点数）。
### 2. 声明结构体变量
定义结构体后，你可以声明该类型的变量：
```c
struct Person person1;
struct Person person2;
```
### 3. 初始化结构体变量
可以直接在声明时初始化结构体变量：
```c
struct Person person1 = {"Alice", 25, 1.75};
```
或者，你也可以逐个成员初始化：
```c
struct Person person2;
strcpy(person2.name, "Bob");
person2.age = 30;
person2.height = 1.80;
```
### 4. 访问结构体成员
使用点号操作符（`.`）来访问结构体的成员：
```c
printf("Name: %s\n", person1.name);
printf("Age: %d\n", person1.age);
printf("Height: %.2f\n", person1.height);
```
### 5. 结构体数组
你可以定义一个结构体数组：
```c
struct Person persons[100];
```
然后访问数组中的结构体成员：
```c
strcpy(persons[0].name, "Charlie");
persons[0].age = 22;
persons[0].height = 1.70;
```
### 6. 结构体指针
你可以声明指向结构体的指针：
```c
struct Person *pPerson;
pPerson = &person1;
```
使用箭头操作符（`->`）来访问指针指向的结构体成员：
```c
printf("Name: %s\n", pPerson->name); // 等同于 (*pPerson).name
```
### 7. 结构体中的结构体
结构体可以包含其他结构体：

```c
struct Address {
    char street[100];
    char city[50];
    char state[20];
    int zip;
};
struct Person {
    char name[50];
    int age;
    float height;
    struct Address address; // 嵌套结构体
};
```
### 8. 结构体大小
结构体的大小由其成员决定，可以使用`sizeof`操作符：
```c
printf("Size of struct Person: %zu bytes\n", sizeof(struct Person));
```
### 9. 结构体对齐
C语言中的结构体成员会自动对齐到其类型所需的边界，以提高内存访问效率。你可以使用`#pragma pack`或`__attribute__((__packed__))`来控制对齐方式。
### 10. 结构体与函数
你可以将结构体作为参数传递给函数，也可以从函数返回结构体：
```c
void printPerson(struct Person p) {
    printf("Name: %s, Age: %d, Height: %.2f\n", p.name, p.age, p.height);
}

struct Person getPerson() {
    struct Person p = {"David", 35, 1.75};
    return p;
}
```
下面是一个使用结构体的简单示例：
```c
#include <stdio.h>
#include <string.h>

// 定义一个名为Person的结构体
struct Person {
    char name[50];  // 名字，最多49个字符（最后一个是'\0'）
    int age;        // 年龄
    float height;   // 身高
};

// 函数：打印Person结构体的信息
void printPerson(struct Person p) {
    printf("Name: %s\n", p.name);
    printf("Age: %d\n", p.age);
    printf("Height: %.2f\n", p.height);
}

// 函数：返回一个Person结构体
struct Person createPerson() {
    struct Person p;
    strcpy(p.name, "Alice");
    p.age = 25;
    p.height = 1.75;
    return p;
}

int main(void) {
    // 声明并初始化一个Person结构体变量
    struct Person person1 = {"Bob", 30, 1.80};
    
    // 打印person1的信息
    printf("Person 1:\n");
    printPerson(person1);

    // 使用函数创建一个新的Person结构体
    struct Person person2 = createPerson();
    
    // 打印person2的信息
    printf("\nPerson 2:\n");
    printPerson(person2);

    // 声明一个指向Person的指针
    struct Person *pPerson;
    pPerson = &person1;
    
    // 使用指针访问结构体成员
    printf("\nPerson 1 (通过指针访问):\n");
    printf("Name: %s\n", pPerson->name);
    printf("Age: %d\n", pPerson->age);
    printf("Height: %.2f\n", pPerson->height);

    return 0;
}
```
这个示例程序展示了以下结构体操作：
1. **定义结构体**：定义了`Person`结构体，包含了名字、年龄和身高。
2. **初始化结构体**：在`main`函数中初始化了`person1`结构体变量。
3. **结构体作为参数传递**：`printPerson`函数接受一个`Person`结构体作为参数，并打印其信息。
4. **从函数返回结构体**：`createPerson`函数创建并返回一个`Person`结构体。
5. **结构体指针**：使用指针来访问结构体成员。
运行这段代码，将看到输出`person1`和`person2`的信息，以及如何通过指针访问结构体成员。

6. **结构体指针运算符**是指用于访问结构体成员的两种操作符：
1. **点号操作符（`.`）**：
  - 用于直接访问结构体变量的成员。
  - 语法：`结构体变量名.成员名`
2. **箭头操作符（`->`）**：
  - 用于访问通过指针指向的结构体成员。
  - 语法：`结构体指针名->成员名`
**箭头操作符（`->`）** 实际上是一个快捷方式，它等同于先解引用指针，然后再使用点号操作符访问成员：
```c
(*结构体指针名).成员名
```
所以，`结构体指针名->成员名` 和 `(*结构体指针名).成员名` 是等价的。
以下是一个示例，展示了这两种操作符的用法：

```c
#include <stdio.h>

struct Person {
    char name[50];
    int age;
};

int main(void) {
    struct Person person = {"Alice", 25};
    struct Person *pPerson = &person;

    // 使用点号操作符访问结构体成员
    printf("Name: %s, Age: %d\n", person.name, person.age);

    // 使用箭头操作符访问结构体成员
    printf("Name: %s, Age: %d\n", pPerson->name, pPerson->age);

    // 等价于箭头操作符的另一种写法
    printf("Name: %s, Age: %d\n", (*pPerson).name, (*pPerson).age);

    return 0;
}
```
在这个示例中：
- `person.name` 和 `person.age` 使用了点号操作符来直接访问`person`结构体变量的成员。
- `pPerson->name` 和 `pPerson->age` 使用了箭头操作符来通过指针访问结构体成员。
- `(*pPerson).name` 和 `(*pPerson).age` 展示了箭头操作符的等价形式。
结构体指针运算符使得通过指针操作结构体变得更加简洁和直观。

联合类型类似于结构，但是成员对象占用的内存是相互重叠的，但两个对象绝对不会同时存在
标签(tag)是用于结构、联合和枚举的特殊命名机制，不饿可以用于声明变量。
联合与枚举的名称同样是标签，而不是类型。这意味着它们也无法单独用于声明变量。
tag独立于普通标识符的命名空间中定义的，这意味着C可以在同一作用域中使用同名的标签和标识符。

类型限定符：const、volatile、restrict。在访问限定类型对象时，这些限定符会改变操作行为。
类型的限定形式和非限定形式可以互换，都能作为函数参数、函数的返回值和联合的成员。
Q:这个联合我还真不太明白。
A：

const限定符声明的对象无法被修改。不能赋值但是可以使用常量初始化器(意思就是初始化可以等于呗)
任何尝试对其进行写入的操作都会导致运行期错误。
是不是就是说可以访问const指针来修改非限定型的变量?

volatile限定类型的对象有其特殊目的。静态volatile限定对象用于内存映射I/O端口模型，静态常量volatile限定对象用于内存映射输入端口模型，比如实时时钟。
volatile好像这个是一个用起来很高难度的？目前看起来好像用不到这个呢

restrict限定指针用于优化。通过指针间接访问的对象往往无法完全优化，原因在于存在潜在的别名。Restrict这个怎么用???

2024/11/28
整数：有符号整数类型表示的值可以是负整数、0或正整数；
无符号整数类型表示的值只能是0或正整数。每种整数类型所能表示的取值范围依赖于实现。
整数对象值的表示则是该值在对象所占的存储空间内的二进制编码。



















